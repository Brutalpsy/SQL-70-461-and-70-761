SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED   -- BE ABLE TO SEE UNCOMMITTED TRANSATIONS / DIRTY DATA / LEAST SEVERE ISOLATION LEVEL
							  --REPEATABLE READ -- ONLY GOOD FOR PRESERVING THE READ STATEMENTS
							  --READ COMMITTED -- DEFAULT ISOLATION LEVEL - NOT ABLE TO READ UNCOMMITTED TRANSATIONS, BUT YOU ARE ABLE TO INSERT NEW DATA
							  --SNAPSHOT -> SAME AS SERIALIZABLE. BUT TAKES QUITE ALOT OF SPACE -> NOT RECOMMENDED
							  --SERIALIZABLE -> BEST ONE IF YOU WAN'T TO PREVENT PHANTOM INSERTS OR MODYFYING THE DATA WHILE TRANSACTION IS RUNNING


-----------------------------------
SET TRANSACTION ISOLATION LEVEL REPEATABLE READ  

-- REPEATABLE READ EXAMPLE AFTER THIS EXECUTE TEST DATA #1
-- AND YOU WONT BE ABLE TO SINCE THE REPEATABLE READ IS NOT CONSISTENT
-- BUT YOU COULD INSERT NEW DATA, DOES NOT APPLY TO INSERTS, IT ONLY STOPS UPDATES
BEGIN TRAN
SELECT * FROM tblEmployee
WAITFOR DELAY '00:00:20'
SELECT * FROM tblEmployee
COMMIT TRAN

--TEST DATA #1
BEGIN TRAN
UPDATE tblEmployee SET EmployeeNumber = 122 WHERE EmployeeNumber = 123 -- SHARED LOCK -> UPDATE LOCK -> EXCLUSIVE LOCK

--------------------------------------------


-- IF YOU WANT TO STOP "PHANDOM READS", THAN YOU SHOULD USE SERIAZIBLE
-- SOLVES ALL THE PROBLEMS
-- IT'S THE MOST SEVERE ISOLATION LEVEL
SET TRANSACTION ISOLATION LEVEL SERIALIZABLE


BEGIN TRAN
SELECT * FROM tblEmployee
WAITFOR DELAY '00:00:20'
SELECT * FROM tblEmployee
COMMIT TRAN

-- PUT THIS TO ANOTHER FILE/NEW QUERY
INSERT INTO [dbo].[tblEmployee]
           ([EmployeeNumber]
           ,[EmployeeFirstName]
           ,[EmployeeMiddleName]
           ,[EmployeeLastName]
           ,[EmployeeGovernmentID]
           ,[DateOfBirth]
           ,[Department])
     VALUES
           (121,'H','I','T','H','20220101','H')

DELETE FROM tblEmployee WHERE EmployeeNumber = 121